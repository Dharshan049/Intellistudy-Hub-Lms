const {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
  } = require("@google/generative-ai");
  
  const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash-exp",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseMimeType: "application/json",
  };

  const generationConfig2 = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseMimeType: "text/plain"
};
  
   export const courseOutline = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate a study material for Python for Exam and easy level of difficulty  will be <Difficulty Level> with summary of course, List of Chapters along with summery  for each chapter, Topic list in each chapter in  JSON format\n"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"courseTitle\": \"Python for Beginners\",\n  \"difficultyLevel\": \"Easy\",\n  \"courseSummary\": \"This course provides a gentle introduction to Python programming.  It covers the fundamental concepts needed to write basic Python programs, focusing on clear explanations and practical examples. No prior programming experience is required.\",\n  \"chapters\": [\n    {\n      \"chapterTitle\": \"Introduction to Python\",\n      \"chapterSummary\": \"This chapter introduces the Python programming language, its applications, and setting up your programming environment.\",\n      \"topics\": [\n        \"What is Python?\",\n        \"Why learn Python?\",\n        \"Installing Python\",\n        \"Using a Python IDE (e.g., Thonny, VS Code)\",\n        \"Running your first Python program\",\n        \"Basic Syntax (indentation, comments)\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Variables and Data Types\",\n      \"chapterSummary\": \"This chapter covers the fundamental building blocks of any program: variables and different types of data they can hold.\",\n      \"topics\": [\n        \"Variables and assignment\",\n        \"Integers (int)\",\n        \"Floating-point numbers (float)\",\n        \"Strings (str)\",\n        \"Booleans (bool)\",\n        \"Type conversion\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Operators\",\n      \"chapterSummary\": \"Learn about different types of operators used to perform operations on data.\",\n      \"topics\": [\n        \"Arithmetic operators (+, -, *, /, //, %, **)\",\n        \"Comparison operators (==, !=, >, <, >=, <=)\",\n        \"Logical operators (and, or, not)\",\n        \"Assignment operators (=, +=, -=, *=, /=)\",\n        \"Operator precedence\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Input and Output\",\n      \"chapterSummary\": \"Learn how to get input from the user and display output to the console.\",\n      \"topics\": [\n        \"The `print()` function\",\n        \"The `input()` function\",\n        \"Formatting output strings (f-strings)\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Control Flow (Conditional Statements)\",\n      \"chapterSummary\": \"This chapter introduces conditional statements to control the flow of execution in your programs.\",\n      \"topics\": [\n        \"`if` statements\",\n        \"`if-else` statements\",\n        \"`if-elif-else` statements\",\n        \"Nested `if` statements\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Loops\",\n      \"chapterSummary\": \"Learn how to repeat blocks of code using loops.\",\n      \"topics\": [\n        \"`for` loops\",\n        \"`while` loops\",\n        \"`break` and `continue` statements\",\n        \"Nested loops\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Basic Data Structures: Lists and Tuples\",\n      \"chapterSummary\": \"This chapter introduces fundamental data structures for storing collections of data.\",\n      \"topics\": [\n        \"Lists: creation, access, modification\",\n        \"List methods (append, insert, remove, pop)\",\n        \"Tuples: creation, access\",\n        \"Difference between lists and tuples\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Functions\",\n      \"chapterSummary\": \"Learn to write reusable blocks of code using functions.\",\n      \"topics\": [\n        \"Defining functions\",\n        \"Function parameters and arguments\",\n        \"Return values\",\n        \"Function calls\"\n      ]\n    }\n  ]\n}\n```\n"},
          ],
        },
      ],
    });

   export const generateNotes = model.startChat({
    generationConfig2,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate exam material detail content for each chapter , Make sure to includes all topic point in the content, make sure to give content in HTML format with emojis that is well formatted to be displayed on a webpage, also we want only the content for each chapter that will be purely HTML (Do not Add HTMLK , Head, Body, title tag), The chapters : \"chapters\": [\n    {\n      \"chapterTitle\": \"Advanced Graph Algorithms\",\n      \"chapterSummary\": \"Dive deep into complex graph algorithms beyond the basics.  Expect challenging implementations and analysis.\",\n      \"emojiIcon\": \"üó∫Ô∏è\",\n      \"topics\": [\n        \"Minimum Cut Algorithms (Karger's Algorithm)\",\n        \"Maximum Flow Algorithms (Push-Relabel, Dinic's)\",\n        \"Network Flow Applications\",\n        \"All Pairs Shortest Paths (Floyd-Warshall)\",\n        \"Advanced Graph Traversal (Articulation Points, Bridges)\",\n        \"Strongly Connected Components (Kosaraju's Algorithm)\",\n        \"Graph Isomorphism\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Dynamic Programming Optimizations\",\n      \"chapterSummary\": \"Explore advanced techniques for optimizing dynamic programming solutions and tackling complex DP problems.\",\n      \"emojiIcon\": \"‚öôÔ∏è\",\n      \"topics\": [\n        \"Bitmasking DP\",\n        \"Convex Hull Trick\",\n        \"Knuth Optimization\",\n        \"Meet-in-the-Middle\",\n        \"Data Structures for DP (Sparse Tables, Segment Trees)\",\n        \"DP on Trees\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Advanced Tree Structures\",\n      \"chapterSummary\": \"Go beyond binary trees to explore more complex and efficient tree structures.\",\n      \"emojiIcon\": \"üå≥\",\n      \"topics\": [\n        \"Trie (Prefix Trees)\",\n        \"Suffix Trees & Suffix Arrays\",\n        \"Segment Trees (Lazy Propagation)\",\n        \"Fenwick Trees (Binary Indexed Trees)\",\n        \"Range Trees\",\n        \"KD-Trees\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"String Algorithms\",\n      \"chapterSummary\": \"Master advanced string algorithms for efficient pattern matching and text processing.\",\n      \"emojiIcon\": \"üî§\",\n      \"topics\": [\n        \"Rabin-Karp Algorithm\",\n        \"Aho-Corasick Algorithm\",\n        \"Manacher's Algorithm (Palindrome Detection)\",\n        \"Suffix Trees & Suffix Arrays (Advanced applications)\",\n        \"Longest Common Subsequence (LCS) optimizations\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Computational Geometry\",\n      \"chapterSummary\": \"Tackle algorithms for solving geometric problems efficiently.\",\n      \"emojiIcon\": \"üìê\",\n      \"topics\": [\n        \"Convex Hull Algorithms (Graham Scan, Gift Wrapping)\",\n        \"Line Segment Intersection\",\n        \"Closest Pair of Points\",\n        \"Voronoi Diagrams\",\n        \"Delaunay Triangulation\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Amortized Analysis & Data Structures\",\n      \"chapterSummary\": \"Analyze the efficiency of data structures over a sequence of operations, not just individual ones.\",\n      \"emojiIcon\": \"‚è±Ô∏è\",\n      \"topics\": [\n        \"Amortized Analysis Techniques\",\n        \"Self-Balancing Binary Search Trees (AVL, Red-Black)\",\n        \"Splay Trees\",\n        \"B-Trees\",\n        \"Skip Lists\"\n      ]\n    },\n    {\n      \"chapterTitle\": \"Advanced Algorithm Design Techniques\",\n      \"chapterSummary\": \"Learn sophisticated techniques for designing efficient algorithms.\",\n      \"emojiIcon\": \"üí°\",\n      \"topics\": [\n        \"Greedy Algorithms (Advanced applications)\",\n        \"Divide and Conquer (Advanced applications)\",\n        \"Randomized Algorithms\",\n        \"Approximation Algorithms\",\n        \"Backtracking & Branch and Bound\"\n      ]\n    }\n  ]\n}"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```html\n<!-- Chapter 1: Advanced Graph Algorithms -->\n<h2>üó∫Ô∏è Advanced Graph Algorithms</h2>\n<p>Dive deep into complex graph algorithms beyond the basics. Expect challenging implementations and analysis.</p>\n<ul>\n  <li><strong>Minimum Cut Algorithms (Karger's Algorithm):</strong>  Understanding and implementing Karger's randomized algorithm for finding minimum cuts in a graph.  Understanding its probabilistic guarantees. üßÆ</li>\n  <li><strong>Maximum Flow Algorithms (Push-Relabel, Dinic's):</strong> Implementing and analyzing Push-Relabel and Dinic's algorithms for finding maximum flows in networks.  Comparing their time complexities. üåä</li>\n  <li><strong>Network Flow Applications:</strong> Applying maximum flow algorithms to solve real-world problems like bipartite matching, assignment problems, and circulation problems.  Practical examples and problem-solving strategies. üíº</li>\n  <li><strong>All Pairs Shortest Paths (Floyd-Warshall):</strong> Understanding and implementing the Floyd-Warshall algorithm for finding shortest paths between all pairs of vertices in a graph.  Analyzing its time complexity. üõ£Ô∏è</li>\n  <li><strong>Advanced Graph Traversal (Articulation Points, Bridges):</strong> Identifying articulation points (cut vertices) and bridges in a graph using Depth-First Search (DFS).  Understanding their significance in graph connectivity. üîó</li>\n  <li><strong>Strongly Connected Components (Kosaraju's Algorithm):</strong> Implementing Kosaraju's algorithm to find strongly connected components in a directed graph.  Understanding the concept of strongly connected components and their applications. üîÑ</li>\n  <li><strong>Graph Isomorphism:</strong> Exploring the problem of determining whether two graphs are isomorphic.  Understanding the complexity and approaches to solving this problem. üîÑ</li>\n</ul>\n\n\n<!-- Chapter 2: Dynamic Programming Optimizations -->\n<h2>‚öôÔ∏è Dynamic Programming Optimizations</h2>\n<p>Explore advanced techniques for optimizing dynamic programming solutions and tackling complex DP problems.</p>\n<ul>\n  <li><strong>Bitmasking DP:</strong> Solving problems using bit manipulation techniques within dynamic programming.  Examples and strategies for efficient bitmasking. üëæ</li>\n  <li><strong>Convex Hull Trick:</strong> Optimizing dynamic programming solutions involving queries of convex functions.  Understanding the underlying principles and implementation. üìà</li>\n  <li><strong>Knuth Optimization:</strong> A technique for optimizing DP solutions with a specific structure, reducing time complexity.  Understanding its applicability and limitations. üéØ</li>\n  <li><strong>Meet-in-the-Middle:</strong>  A divide-and-conquer approach to reduce the time complexity of DP problems by splitting the problem into smaller subproblems. ü§ù</li>\n  <li><strong>Data Structures for DP (Sparse Tables, Segment Trees):</strong> Utilizing data structures like sparse tables and segment trees to efficiently query and update DP states. üóÇÔ∏è</li>\n  <li><strong>DP on Trees:</strong>  Solving dynamic programming problems on tree structures.  Techniques for efficient traversal and computation. üå≥</li>\n</ul>\n\n\n<!-- Chapter 3: Advanced Tree Structures -->\n<h2>üå≥ Advanced Tree Structures</h2>\n<p>Go beyond binary trees to explore more complex and efficient tree structures.</p>\n<ul>\n  <li><strong>Trie (Prefix Trees):</strong> Implementing and utilizing Trie data structures for efficient prefix searching and string operations.  Applications and advantages. üî§</li>\n  <li><strong>Suffix Trees & Suffix Arrays:</strong>  Understanding the construction and applications of suffix trees and suffix arrays for efficient string matching and pattern searching. üîé</li>\n  <li><strong>Segment Trees (Lazy Propagation):</strong> Implementing segment trees with lazy propagation for efficient range queries and updates.  Understanding the optimization provided by lazy propagation. üìä</li>\n  <li><strong>Fenwick Trees (Binary Indexed Trees):</strong> Implementing and utilizing Fenwick trees for efficient range sum queries and updates.  Comparing it with segment trees. üìà</li>\n  <li><strong>Range Trees:</strong>  Understanding and implementing range trees for efficient multi-dimensional range queries.  Applications and complexity analysis. üó∫Ô∏è</li>\n  <li><strong>KD-Trees:</strong>  Implementing and utilizing KD-trees for efficient nearest neighbor searches in multi-dimensional spaces.  Comparing it with other spatial data structures. üìç</li>\n</ul>\n\n\n<!-- Chapter 4: String Algorithms -->\n<h2>üî§ String Algorithms</h2>\n<p>Master advanced string algorithms for efficient pattern matching and text processing.</p>\n<ul>\n  <li><strong>Rabin-Karp Algorithm:</strong> Implementing the Rabin-Karp algorithm for pattern searching using hashing.  Analyzing its time complexity and handling collisions. üîé</li>\n  <li><strong>Aho-Corasick Algorithm:</strong> Implementing the Aho-Corasick algorithm for efficient multiple pattern searching.  Understanding its automaton-based approach. ü§ñ</li>\n  <li><strong>Manacher's Algorithm (Palindrome Detection):</strong> Implementing Manacher's linear time algorithm for finding all palindromic substrings in a string.  Understanding its efficiency.  palindrome</li>\n  <li><strong>Suffix Trees & Suffix Arrays (Advanced applications):</strong> Advanced applications of suffix trees and suffix arrays, including longest common substrings and other string problems. üìö</li>\n  <li><strong>Longest Common Subsequence (LCS) optimizations:</strong> Optimizing the dynamic programming solution for the Longest Common Subsequence problem.  Exploring space and time optimization techniques. üñáÔ∏è</li>\n</ul>\n\n\n<!-- Chapter 5: Computational Geometry -->\n<h2>üìê Computational Geometry</h2>\n<p>Tackle algorithms for solving geometric problems efficiently.</p>\n<ul>\n  <li><strong>Convex Hull Algorithms (Graham Scan, Gift Wrapping):</strong> Implementing and comparing the Graham Scan and Gift Wrapping algorithms for finding the convex hull of a set of points. üî∂</li>\n  <li><strong>Line Segment Intersection:</strong>  Efficiently detecting intersections between line segments.  Algorithms and data structures for handling intersections.  –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ</li>\n  <li><strong>Closest Pair of Points:</strong> Finding the closest pair of points in a set of points using efficient algorithms.  Divide and conquer approaches. üìç</li>\n  <li><strong>Voronoi Diagrams:</strong> Understanding and constructing Voronoi diagrams for a set of points.  Applications and algorithms. üåê</li>\n  <li><strong>Delaunay Triangulation:</strong> Understanding and constructing Delaunay triangulations for a set of points.  Relationship to Voronoi diagrams. üî∫</li>\n</ul>\n\n\n<!-- Chapter 6: Amortized Analysis & Data Structures -->\n<h2>‚è±Ô∏è Amortized Analysis & Data Structures</h2>\n<p>Analyze the efficiency of data structures over a sequence of operations, not just individual ones.</p>\n<ul>\n  <li><strong>Amortized Analysis Techniques:</strong>  Understanding different amortized analysis techniques like aggregate, accounting, and potential methods. üßÆ</li>\n  <li><strong>Self-Balancing Binary Search Trees (AVL, Red-Black):</strong> Implementing and analyzing self-balancing BSTs like AVL and Red-Black trees.  Understanding their properties and balancing mechanisms. üå≤</li>\n  <li><strong>Splay Trees:</strong> Understanding and implementing splay trees, their self-adjusting nature, and amortized performance guarantees. üîÑ</li>\n  <li><strong>B-Trees:</strong> Understanding and implementing B-trees for efficient disk-based data storage and retrieval.  Analyzing their properties and performance characteristics. üóÑÔ∏è</li>\n  <li><strong>Skip Lists:</strong> Understanding and implementing skip lists, a probabilistic data structure for efficient search, insertion, and deletion. üîó</li>\n</ul>\n\n\n<!-- Chapter 7: Advanced Algorithm Design Techniques -->\n<h2>üí° Advanced Algorithm Design Techniques</h2>\n<p>Learn sophisticated techniques for designing efficient algorithms.</p>\n<ul>\n  <li><strong>Greedy Algorithms (Advanced applications):</strong>  Advanced applications of greedy algorithms, including Huffman coding and other optimization problems.  Analyzing the limitations of greedy approaches. üí∞</li>\n  <li><strong>Divide and Conquer (Advanced applications):</strong> Advanced applications of divide and conquer, beyond merge sort and quicksort.  Examples and problem-solving strategies. üß©</li>\n  <li><strong>Randomized Algorithms:</strong>  Understanding and implementing randomized algorithms, such as randomized quicksort and Monte Carlo methods.  Analyzing their expected performance. üé≤</li>\n  <li><strong>Approximation Algorithms:</strong>  Understanding the concept of approximation algorithms for NP-hard problems.  Examples and techniques for designing approximation algorithms. üìè</li>\n  <li><strong>Backtracking & Branch and Bound:</strong> Implementing and analyzing backtracking and branch and bound algorithms for solving combinatorial optimization problems.  Understanding their exploration strategies. üå≤</li>\n</ul>\n```\n"},
          ],
        },
      ],
    });

    export const GenerateStudyTypeContentAiModel = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate the flashcard on topic : Flutter Fundamentals,User Interface (UI) Development,Basic App Navigation in JSON format with front back content, Maximum 15"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n[\n  {\n    \"front\": \"What is a Widget in Flutter?\",\n    \"back\": \"A Widget is the fundamental building block of Flutter's UI.  Everything you see on the screen is a widget, including layouts, text, images, and buttons.\"\n  },\n  {\n    \"front\": \"What are the two main types of Widgets?\",\n    \"back\": \"StatelessWidget (immutable) and StatefulWidget (mutable).\"\n  },\n  {\n    \"front\": \"Explain the difference between StatelessWidget and StatefulWidget.\",\n    \"back\": \"StatelessWidget doesn't change its state over time, while StatefulWidget can rebuild itself based on changes in its state.\"\n  },\n  {\n    \"front\": \"Name three common layout widgets.\",\n    \"back\": \"Row, Column, and Stack.\"\n  },\n  {\n    \"front\": \"What is the purpose of a Scaffold widget?\",\n    \"back\": \"Scaffold provides a basic visual layout structure for an app, including app bar, body, floating action button, etc.\"\n  },\n  {\n    \"front\": \"How do you display text in Flutter?\",\n    \"back\": \"Using the Text widget.\"\n  },\n  {\n    \"front\": \"What widget is used for images?\",\n    \"back\": \"Image.asset or Image.network\"\n  },\n  {\n    \"front\": \"What is the purpose of a Container widget?\",\n    \"back\": \"Provides padding, margin, color, and other styling properties to its child widget(s).\"\n  },\n  {\n    \"front\": \"How do you navigate to a new screen in Flutter?\",\n    \"back\": \"Using Navigator.push().\"\n  },\n  {\n    \"front\": \"What is the role of Navigator in Flutter?\",\n    \"back\": \"Manages a stack of routes (screens) in your application.\"\n  },\n  {\n    \"front\": \"What is Material Design?\",\n    \"back\": \"A design language developed by Google, providing a consistent visual style for applications.\"\n  },\n  {\n    \"front\": \"What is a Route in Flutter navigation?\",\n    \"back\": \"A Route represents a single screen or page in your app's navigation.\"\n  },\n  {\n    \"front\": \"How do you pass data to a new screen during navigation?\",\n    \"back\": \"Using arguments within Navigator.push() and accessing them in the new screen's constructor.\"\n  },\n  {\n    \"front\": \"What is the purpose of `BuildContext`?\",\n    \"back\": \"Provides access to the widget tree's information, such as the parent widget and theme.\"\n  },\n  {\n    \"front\": \"What's the difference between `push` and `pushReplacement` in navigation?\",\n    \"back\": \"`push` adds a new route to the stack, while `pushReplacement` replaces the current route with a new one.\"\n  }\n]\n```\n"},
          ],
        },
      ],
    });


    export const GenerateQuizAiModel = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "Generate Quiz on topic : Flutter Fundamentals, User Interface (UI) Development, Basic App Navigation with Question and Options along with correct answer in JSON format\n"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"quizTitle\": \"Flutter Fundamentals, UI & Navigation\",\n  \"questions\": [\n    {\n      \"question\": \"What is the main widget used to build a Flutter application?\",\n      \"options\": [\"Widget\", \"StatelessWidget\", \"MaterialApp\", \"Scaffold\"],\n      \"correctAnswer\": \"MaterialApp\"\n    },\n    {\n      \"question\": \"Which widget is used to display a single line of text in Flutter?\",\n      \"options\": [\"Text\", \"TextField\", \"Container\", \"Row\"],\n      \"correctAnswer\": \"Text\"\n    },\n    {\n      \"question\": \"What does StatelessWidget do?\",\n      \"options\": [\"Updates its UI dynamically based on state changes\", \"Provides a single immutable description of the UI\", \"Manages the state of a widget tree\", \"Handles user interactions\"],\n      \"correctAnswer\": \"Provides a single immutable description of the UI\"\n    },\n    {\n      \"question\": \"Which widget is best suited for arranging children in a column?\",\n      \"options\": [\"Row\", \"Column\", \"Stack\", \"Container\"],\n      \"correctAnswer\": \"Column\"\n    },\n    {\n      \"question\": \"How do you navigate to a new route in Flutter using named routes?\",\n      \"options\": [\"Navigator.push(context, MaterialPageRoute(builder: (context) => NewScreen()))\", \"Navigator.pushNamed(context, '/newScreen')\", \"Navigator.pop(context)\", \"Route.generate(context, '/newScreen')\"],\n      \"correctAnswer\": \"Navigator.pushNamed(context, '/newScreen')\"\n    },\n    {\n      \"question\": \"What widget is used to create a scrollable list of items?\",\n      \"options\": [\"ListView\", \"GridView\", \"Stack\", \"Column\"],\n      \"correctAnswer\": \"ListView\"\n    },\n    {\n      \"question\": \"Which widget provides a visual indicator of the current screen in a navigation app?\",\n      \"options\": [\"AppBar\", \"Scaffold\", \"BottomNavigationBar\", \"Container\"],\n      \"correctAnswer\": \"AppBar\" \n    },\n    {\n      \"question\": \"What does the `key` property in a widget do?\",\n      \"options\": [\"It's used for styling the widget\", \"It's used for uniquely identifying a widget\", \"It's used to control the widget's size\", \"It's used to handle user input\"],\n      \"correctAnswer\": \"It's used for uniquely identifying a widget\"\n    },\n    {\n      \"question\": \"What is the purpose of a `StatefulWidget`?\",\n      \"options\": [\"Creates a static UI that doesn't change\", \"Manages the state of a widget and rebuilds when the state changes\", \"Handles navigation between screens\", \"Provides access to the build context\"],\n      \"correctAnswer\": \"Manages the state of a widget and rebuilds when the state changes\"\n    },\n    {\n      \"question\": \"Which widget allows you to create interactive buttons?\",\n      \"options\": [\"Text\", \"Container\", \"ElevatedButton\", \"Icon\"],\n      \"correctAnswer\": \"ElevatedButton\"\n    }\n  ]\n}\n```\n"},
          ],
        },
      ],
    });
    
    export const GenerateQaAiModel = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {
              text: 'Create **15 question-and-answer pairs** based on the following topics: \n        Advanced Java Concepts, Spring Framework Mastery, Microservices Architecture, RESTful API Design and Development, Frontend Development with React, Database Management with Advanced SQL\n\n        The Answer should be at least of 10 lines\t\n\n### **Output Requirements**\n1. **Questions and Answers:**\n   - Each question must be concise and directly address one of the topics above.\n   - Each answer should be **detailed and explanatory**, providing:\n     - A clear explanation of the concept.\n     - Examples or scenarios illustrating the answer where applicable.\n     - Practical tips or best practices.\n\n\n### **Output Example for a Question**\nemoji: A relevant emoji to visually represent the chapter.\ncontent (string): Detailed content for the topic written in Md format, and ready for rendering in a React.js component.\n\n2. Content Formatting:\nGive me in .md format\n{\n  "questions": [\n    {\n      "question": "",\n      "answer": ""\n    }\n}\n\n**IMPORTANT**\nThere should be an emoji\nGive me in .md format\n\n\n\n 7. **Additional Notes:**  \n   - **IMPORTANT** There should be an emoji\n   - Every Content should be in detail and explained properly\n   - Each \'content\' field should use simple and concise language suitable for study notes.  \n   - Ensure that topics include clear definitions, key points, and, where appropriate, examples or sample code.  \n   - All generated content should be focused on clarity and exam preparation, with minimal redundancy.  \n\n 8. **Avoid Common Errors:**  \n   - Double-check for mismatched brackets, missing fields, or improperly formatted strings.  \n',
            },
          ],
        },
        {
          role: "model",
          parts: [
            {
              text: '```json\n{\n  "questions": [\n    {\n      "question": "üíª Explain the concept of Java Streams and its advantages over traditional loops.",\n      "answer": "Java Streams provide a declarative way to process collections of data. Unlike traditional loops (for, while), which are imperative and specify *how* to process data, Streams declare *what* needs to be done.  This functional approach enhances code readability and maintainability.  \\n\\nAdvantages:\\n* **Conciseness:** Streams often require fewer lines of code compared to loops.\\n* **Readability:** The declarative style improves code understanding.\\n* **Parallelism:** Streams easily support parallel processing, significantly speeding up computations on large datasets.  This is achieved using `parallelStream()`.\\n* **Lazy Evaluation:**  Intermediate operations in a stream pipeline are not executed until a terminal operation (like `collect()`, `forEach()`, `reduce()`) is called. This optimizes performance by avoiding unnecessary computations.\\n* **Composability:**  Multiple stream operations can be chained together, creating elegant and expressive data pipelines.\\n\\nExample:\\n```java\\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\\nint sum = numbers.stream().filter(n -> n % 2 == 0).map(n -> n * 2).reduce(0, Integer::sum);\\nSystem.out.println(sum); // Output: 60\\n```\\nThis code calculates the sum of even numbers after doubling them using streams.  The equivalent using a loop would be significantly longer and less readable.\\n\\nBest Practices:\\n* Use streams for operations involving collections.\\n* Leverage parallel streams for performance gains on large datasets.\\n* Understand the difference between intermediate and terminal operations.\\n* Avoid excessive chaining to prevent code complexity."\n    },\n    {\n      "question": "üå± What are Spring beans and dependency injection?  Illustrate with an example.",\n      "answer": "In Spring Framework, a bean is an object that is instantiated, assembled, and managed by the Spring IoC (Inversion of Control) container.  Dependency Injection (DI) is a design pattern where dependencies are provided to a class instead of the class creating them itself. Spring manages this injection process automatically.\\n\\nHow it Works:\\nThe Spring container reads configuration metadata (usually from XML, annotations, or Java-based configurations) to determine which beans to create and how to wire them together.  DI eliminates hard-coded dependencies, making code more flexible, testable, and maintainable.\\n\\nExample:\\nLet\'s say we have a `Car` class that depends on an `Engine` class:\\n```java\\n// Car class\\npublic class Car {\\n    private Engine engine;\\n\\n    // Constructor-based injection\\n    public Car(Engine engine) {\\n        this.engine = engine;\\n    }\\n    // ... other methods ...\\n}\\n\\n// Engine class\\npublic class Engine {\\n    // ...\\n}\\n```\\nIn the Spring configuration, we define the beans and specify the dependency:\\n```xml\\n<bean id=\\"engine\\" class=\\"com.example.Engine\\" />\\n<bean id=\\"car\\" class=\\"com.example.Car\\">\\n    <constructor-arg ref=\\"engine\\" />\\n</bean>\\n```\\nSpring automatically creates an `Engine` bean and injects it into the `Car` bean\'s constructor.  This removes the responsibility of creating the `Engine` from the `Car` class.\\n\\nBest Practices:\\n* Use constructor injection whenever possible for better control and testability.\\n* Use annotations (`@Component`, `@Autowired`, `@Service`, etc.) for simpler configuration.\\n* Understand the different scopes of beans (singleton, prototype, etc.)."\n    },\n    {\n      "question": "üåê Describe the key characteristics of a microservices architecture.",\n      "answer": "Microservices architecture is an approach to software development where a large application is structured as a collection of small, autonomous services. Each service focuses on a specific business function and communicates with others via lightweight mechanisms, often RESTful APIs. \\n\\nKey Characteristics:\\n* **Independent Deployability:** Each microservice can be deployed, scaled, and updated independently of others. This allows for faster release cycles and better fault isolation.\\n* **Decentralized Governance:** Teams can choose their own technologies and development processes for each service. This promotes innovation and faster development.\\n* **Bounded Contexts:** Each microservice represents a specific business domain or sub-domain. This promotes modularity and reduces complexity.\\n* **Resilience:** Failure of one microservice should not bring down the entire application. This is achieved through techniques like circuit breakers and fault tolerance.\\n* **Data Decentralization:**  Each microservice typically owns its own data.  This can lead to data consistency challenges, requiring careful management.\\n* **Technology Diversity:** Teams can choose the technologies best suited for each service\'s requirements.\\n\\nChallenges:\\n* **Increased Complexity:** Managing many services can be challenging.  Requires robust monitoring and logging.\\n* **Distributed Transactions:** Maintaining data consistency across multiple services can be difficult.\\n* **Inter-service Communication:** Choosing and managing communication protocols is important.\\n\\nExample:\\nAn e-commerce application might have separate microservices for user accounts, product catalog, order management, and payment processing. Each can be developed, deployed, and scaled independently."\n    },\n    {\n      "question": "üîó Explain the principles of RESTful API design.",\n      "answer": "REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs use HTTP methods (GET, POST, PUT, DELETE) to interact with resources.  Key principles:\\n\\n* **Client-Server:**  The client and server are independent and can be developed and updated separately.\\n* **Stateless:** Each request from the client to the server must contain all the information necessary to understand the request. The server doesn\'t maintain client context between requests.\\n* **Cacheable:** Responses from the server should be cacheable to improve performance.  HTTP headers like `Cache-Control` manage caching.\\n* **Uniform Interface:** A consistent interface should be used for interacting with resources.  This promotes simplicity and interoperability.\\n    * **Resources are identified by URIs:** (e.g., `/users/{id}`).\\n    * **Standard HTTP methods are used:** GET (retrieve), POST (create), PUT (update), DELETE (delete).\\n    * **Representations of resources are returned:** (e.g., JSON or XML).\\n    * **Hypermedia controls:**  Links in responses guide clients to related resources (HATEOAS).\\n* **Layered System:**  The client typically interacts with a load balancer or API gateway which forwards the request to the actual microservices.\\n* **Code on Demand (optional):**  The server can extend client functionality by transferring executable code.\\n\\nBest Practices:\\n* Use meaningful URLs.\\n* Employ proper HTTP status codes.\\n* Use consistent data formats (JSON is common).\\n* Implement appropriate error handling and logging.\\n* Design for scalability and maintainability.\\n* Use versioning to manage API changes."\n    },\n    {\n      "question": "‚öõÔ∏è  Discuss the key features and benefits of React.js for frontend development.",\n      "answer": "React.js is a popular JavaScript library for building user interfaces (UIs). It\'s known for its component-based architecture, virtual DOM, and JSX syntax.\\n\\nKey Features:\\n* **Component-Based Architecture:** UIs are built using reusable components, improving code organization and maintainability.  Components manage their own state and render their own output.\\n* **Virtual DOM:** React uses a virtual DOM (Document Object Model) to optimize updates.  Changes are first applied to the virtual DOM, then efficiently updated in the actual DOM, improving performance.\\n* **JSX:** JSX (JavaScript XML) allows writing HTML-like code within JavaScript, making it easier to create UI elements.\\n* **One-way Data Binding:**  Data flows in a single direction, simplifying state management and reducing complexity.\\n* **Large Community and Ecosystem:** Abundant resources, third-party libraries, and tools are available.\\n\\nBenefits:\\n* **Increased Productivity:** Component reusability and simplified development process leads to faster development.\\n* **Improved Performance:** Virtual DOM optimizes rendering for a smoother user experience.\\n* **Easier Debugging and Maintenance:**  Modular design and component-based architecture improve code readability and maintainability.\\n* **Code Reusability:** Components can be used across different projects.\\n* **SEO-Friendly:**  React applications can be rendered server-side (SSR) for better SEO.\\n\\nExample:\\nA simple React component:\\n```javascript\\nfunction Welcome(props) {\\n  return <h1>Hello, {props.name}</h1>;\\n}\\n```\\nThis component takes a `name` prop and renders a greeting message."\n    },\n    {\n      "question": "üóÑÔ∏è Explain the concept of database normalization and its importance.",\n      "answer": "Database normalization is a process of organizing data to reduce redundancy and improve data integrity.  It involves breaking down a database into two or more tables and defining relationships between the tables.\\n\\nImportance:\\n* **Reduces Data Redundancy:**  Eliminating duplicate data saves storage space and improves data consistency.\\n* **Enhances Data Integrity:** Ensures that data is accurate and reliable.  Changes to data are made in only one location.\\n* **Improves Data Management:** Simplifies queries and data modification.  Easier to manage and maintain.\\n* **Minimizes Data Anomalies:** Prevents update, insertion, and deletion anomalies.  These are inconsistencies that occur when data is not properly structured.\\n\\nNormal Forms:\\nDatabase normalization is often described in terms of normal forms (1NF, 2NF, 3NF, BCNF, etc.).  Each normal form represents a level of data organization.\\n* **1NF (First Normal Form):**  Eliminates repeating groups of data within a table. Each column should contain atomic values (single values).\\n* **2NF (Second Normal Form):**  Must be in 1NF and eliminate redundant data that depends on only part of the primary key (in tables with composite keys).\\n* **3NF (Third Normal Form):** Must be in 2NF and eliminate transitive dependency; values should depend directly on the primary key, not indirectly via other non-key attributes.\\n\\nExample:\\nA poorly normalized table (students and courses):\\n| StudentID | Name  | Course1 | Course2 |\\n|---|---|---|---| \\n| 1 | John  | Math   | Science |\\n| 2 | Jane  | Science | History |\\n\\nNormalized tables:\\n**Students:**\\n| StudentID | Name |\\n|---|---| \\n| 1 | John  |\\n| 2 | Jane  |\\n\\n**Courses:**\\n| CourseID | CourseName |\\n|---|---| \\n| 1 | Math   |\\n| 2 | Science |\\n| 3 | History |\\n\\n**StudentCourses:**\\n| StudentID | CourseID |\\n|---|---| \\n| 1 | 1 |\\n| 1 | 2 |\\n| 2 | 2 |\\n| 2 | 3 |"\n    },\n    {\n      "question": "üß± Explain the concept of ACID properties in database transactions.",\n      "answer": "ACID properties are a set of four characteristics that guarantee database transactions are processed reliably. These properties ensure data consistency and integrity even in the event of failures:\\n\\n* **Atomicity:** A transaction is treated as a single, indivisible unit of work. Either all operations within the transaction are completed successfully, or none are.  If any part fails, the entire transaction is rolled back to its previous state.\\n* **Consistency:**  A transaction must maintain the database\'s integrity constraints. The database must remain in a valid state before and after a transaction. It should not violate any rules or constraints set up (e.g., data types, foreign key constraints).\\n* **Isolation:**  Concurrent transactions must be isolated from each other.  Changes made by one transaction are not visible to other transactions until the first transaction is completed. This avoids data corruption caused by race conditions.\\n* **Durability:**  Once a transaction is committed, the changes are permanently saved to the database, even if a system failure occurs.  The data is persisted, even through crashes or power outages.\\n\\nExample:\\nImagine transferring money from one bank account to another.  ACID properties ensure:\\n* **Atomicity:**  Either both debiting and crediting occur, or neither does. No partial transfers are possible.\\n* **Consistency:**  The total amount of money remains the same after the transaction.\\n* **Isolation:**  Other users cannot see the intermediate state where one account is debited but the other is not yet credited.\\n* **Durability:** The transaction is permanently recorded, even if the system crashes immediately after it is completed."\n    },\n    {\n      "question": "‚öôÔ∏è What is the purpose of a connection pool in database management?",\n      "answer": "A database connection pool is a caching mechanism that improves database application performance by reusing connections instead of repeatedly creating and closing them.  Creating a database connection is a resource-intensive operation, so pooling minimizes the overhead and makes the application more responsive. \\n\\nHow it Works:\\nThe pool maintains a set of active and idle database connections. When an application needs a connection, it requests one from the pool.  If an idle connection is available, it\'s reused; otherwise, a new connection is created (up to a maximum limit). When the application is finished with the connection, it returns it to the pool, where it becomes available for reuse. Connections that remain idle for a long time are eventually closed to manage resources.\\n\\nBenefits:\\n* **Improved Performance:** Reduced overhead associated with connection creation and destruction leads to faster application response times.\\n* **Resource Management:** Efficiently manages database connections, preventing resource exhaustion.\\n* **Scalability:**  Facilitates scaling of applications by providing a readily available pool of connections to handle increased traffic.\\n* **Connection Lifetime Management:**  Provides controls for connection timeout and recycling, preventing issues related to stale connections. \\n\\nCommon Pooling Libraries:\\n* HikariCP (popular choice for its speed and efficiency).\\n* c3p0\\n* Apache Commons DBCP"\n    },\n    {\n      "question": "üí° Explain the concept of Java Generics and its benefits.",\n      "answer": "Generics in Java allow you to write type-safe code that can work with various data types without losing type information at compile time.  Before generics, collections like `ArrayList` stored `Object` types, requiring explicit casting, which could lead to runtime `ClassCastException` errors. Generics solved this by introducing type parameters.\\n\\nBenefits:\\n* **Type Safety:**  Compile-time type checking prevents `ClassCastException` errors.  The compiler ensures only compatible types are used.\\n* **Improved Code Readability:**  Generics make code clearer by explicitly indicating the types being used.\\n* **Reduced Code Duplication:**  You can write a single generic class or method that works with different types, eliminating the need to write separate versions for each type.\\n* **Enhanced Maintainability:**  Changes to types are automatically propagated throughout the code, reducing the risk of errors.\\n\\nExample:\\n```java\\nList<String> names = new ArrayList<>(); // List of Strings\\nnames.add(\\"Alice\\");\\nnames.add(\\"Bob\\");\\nString name = names.get(0); // No casting needed\\n```\\nWithout generics, `names` would be `List<Object>`, and getting elements would require casting: `String name = (String) names.get(0);` ‚Äì which is prone to errors if the list contains non-String objects.\\n\\nBest Practices:\\n* Use generics whenever possible to improve type safety and code clarity.\\n* Use wildcards (`? extends T`, `? super T`) for more flexible type handling.\\n* Avoid raw types (e.g., `ArrayList` instead of `ArrayList<String>`), as they defeat the purpose of generics."\n    },\n    {\n      "question": "üõ†Ô∏è Describe different types of Spring dependency injection.",\n      "answer": "Spring Framework provides several ways to inject dependencies into beans:\\n\\n* **Constructor Injection:** Dependencies are passed as arguments to a class\'s constructor.  This approach is generally preferred as it ensures all required dependencies are provided.  It promotes immutability and better testability because dependencies are immediately available when the bean is created.\\n* **Setter Injection:** Dependencies are injected using setter methods. This allows for setting dependencies after the bean is created.  It\'s useful for optional dependencies but can lead to objects not being fully configured if dependencies are not set appropriately.\\n* **Field Injection:** Dependencies are directly injected into a bean\'s fields using `@Autowired` annotation.  This approach is generally discouraged because it reduces readability and testability; it bypasses constructor and setter validation, and the object might not be in a valid state until all fields are injected. \\n\\nExample (Constructor Injection):\\n```java\\npublic class Car {\\n    private final Engine engine;\\n\\n    @Autowired // Spring handles this injection\\n    public Car(Engine engine) {\\n        this.engine = engine;\\n    }\\n}\\n```\\nExample (Setter Injection):\\n```java\\npublic class Car {\\n    private Engine engine;\\n\\n    @Autowired // Spring handles this injection\\n    public void setEngine(Engine engine) {\\n        this.engine = engine;\\n    }\\n}\\n```\\nChoosing the right method depends on the specifics of the application. Constructor injection is generally recommended for mandatory dependencies, while setter injection is suitable for optional ones."\n    },\n    {\n      "question": "üóÇÔ∏è Explain different types of database relationships.",\n      "answer": "Database relationships define how data in different tables is connected.  The most common types are:\\n\\n* **One-to-One:**  A single record in one table is related to a single record in another table. Example: A `person` table and a `passport` table, where one person has at most one passport.\\n* **One-to-Many:** A single record in one table can be related to multiple records in another table.  Example: A `customer` table and an `order` table, where one customer can have multiple orders.\\n* **Many-to-One:**  Multiple records in one table can be related to a single record in another table. This is the inverse of a one-to-many relationship. Example: Multiple `employees` can report to a single `manager`.\\n* **Many-to-Many:** Multiple records in one table can be related to multiple records in another table. Example:  `students` and `courses`, where multiple students can take multiple courses. This relationship usually requires a junction table (or bridge table) to represent the association.\\n\\nImplementation:\\nThese relationships are implemented using foreign keys. A foreign key in one table references the primary key of another table, creating the link between the records.  For many-to-many relationships, the junction table has foreign keys to both participating tables."\n    },\n    {\n      "question": "üîÑ Explain the concept of state management in React.",\n      "answer": "State management in React refers to how you handle and update data that changes over time in your application. Effectively managing state is crucial for building complex React apps that are predictable, maintainable, and performant.  Without a well-defined strategy, large React apps become difficult to debug and update.\\n\\nApproaches to State Management:\\n* **Local State (useState):** For simple components, you can manage state directly using the `useState` hook.  The state is contained within the component, making it easy to manage, but not ideal for complex apps where state needs to be shared across many components.\\n* **Component State (lifting state up):**  For state that needs to be shared across several child components, you can ‚Äòlift state up‚Äô to the nearest common ancestor component, passing the state and update functions down as props. While this works for moderately complex applications, it becomes cumbersome as the app grows.\\n* **Context API:** Provides a way to share state globally across the application.  Useful for data that is used across many components, but it can become difficult to manage in very large apps.\\n* **Redux (and other state management libraries):** Redux, Zustand, Jotai, and Recoil are more advanced state management libraries that provide features like centralized state management, unidirectional data flow, and time-travel debugging. They\'re suitable for large-scale applications but add complexity.  Each library has its own approach; Redux is the most established but can feel overly complex for some projects.  Zustand is a popular alternative that\'s lightweight and easy to learn.\\n\\nChoosing the Right Approach:\\nStart with local state and lifting state up for smaller applications.  As your app grows, consider the Context API or a dedicated state management library like Redux or Zustand to maintain scalability and maintainability."\n    },\n    {\n      "question": "üåê  Explain the role of an API Gateway in a microservices architecture.",\n      "answer": "In a microservices architecture, an API Gateway acts as a single entry point for all client requests.  It sits in front of the multiple microservices that make up the application and provides several key functionalities:\\n\\n* **Request Routing:** The API Gateway routes incoming requests to the appropriate microservices based on the request\'s path and other criteria.  This hides the internal structure of the application from clients.\\n* **Authentication and Authorization:** The API Gateway can handle authentication and authorization, securing access to the microservices. It centralizes security, rather than having each microservice implement its own security logic.\\n* **Request Transformation:** The Gateway can transform requests or responses to match the needs of the clients or the microservices.  It might adjust data formats, aggregate data from multiple services, or filter data.\\n* **Load Balancing:** Distributes requests across multiple instances of a microservice to ensure high availability and performance.\\n* **Rate Limiting:** Prevents abuse by limiting the number of requests a client can make within a given time period.\\n* **Monitoring and Logging:** The Gateway can monitor and log all incoming and outgoing traffic, providing insights into application performance and usage.\\n* **Caching:** Caches frequently accessed data to improve performance and reduce load on the microservices.\\n\\nBenefits:\\n* **Simplified Client Interactions:** Clients interact with a single endpoint instead of many individual microservices.\\n* **Improved Security:** Centralized authentication and authorization enhance security.\\n* **Enhanced Performance:** Request transformation, load balancing, and caching improve performance.\\n* **Reduced Complexity:** Abstracts the internal complexity of the microservices from the clients."\n    }\n  ]\n}\n```\n',
            },
          ],
        },
      ],
    });
    
    // const result = await chatSession.sendMessage("INSERT_INPUT_HERE");
    // console.log(result.response.text());
